#!/bin/bash
# This script should be located at /usr/local/sbin/golem

################################################################################
#                                                                              #
#    Globals                                                                   #
#                                                                              #
################################################################################

# Name of this script.
# shellcheck disable=SC2034
scriptname=$(basename "$_")
# And the path.
scriptpath=$(readlink -m "$0")
scriptdir=$(dirname "$scriptpath")

# restrict newly created files to read/write by this user only.
umask 077

# Batch (quiet) mode?
batch=0


################################################################################
#                                                                              #
#    Functions                                                                 #
#                                                                              #
################################################################################

##
# Return the path to the script file from either the cache or the script source
# directory whose name best matches the command the user wants to run.
# 
_find_cmd_file () {
    # Make sure the local "scripts" and ".cache" directories are present.
    mkdir -p "$scriptdir"/scripts
    mkdir -p "$scriptdir"/.cache
    for lookdir in ".cache" "scripts"; do
        # Iterate over the list of files in this directory from longest file
        # name to shortest.
        # The correct way to do this is to redirect the output from this nasty
        # series of commands as a redirect into `done`, e.g.:
        #     done < <(....)
        # But older verions of Bash vomit when you try that. Piping doesn't
        # work nicely on newer versions of Bash because it creates a subshell
        # which prevents later code from accessing any variables that are set,
        # exit doesn't work because the pipe is a subshell (it just exits the
        # pipe). So ... early return from a function!
        for scriptfile in "$scriptdir"/"$lookdir"/*; do echo ${#scriptfile} "$scriptfile"; done | sort -rn | cut -d " " -f 2 | while read -r filename; do
            # Convert the filename into a regular expression...
            regex=$(path_basename "$filename" | sed 's/_/[[:space:]]\\{1,\\}.*[[:space:]]*/g')
            # ...and then try to match it against the entered command.
            if echo "$*" | grep -q "^$regex"; then
                echo "$filename"
                return 0
            fi
        done
    done
    echo ""
    return 1
}


##
# Verify the integrity of the script cache: ensures the source file still exists,
# there's only one matching source file for the cache entry, and the timestamps
# still match. If any of these aren't true, then the cache gets updated or an
# error message is displayed and the command fails.
#
_cache_check () {
    file_basename="$1"
    # Locate matching source and cache file(s).
    sourcefiles=("$scriptdir"/scripts/"$file_basename".*)
    cachedfiles=("$scriptdir"/.cache/"$file_basename".*)
    # See if a cache update can be skipped.
    # The current version of bash should return a single-element array containing
    # the input glob if no matches were found, but future versions may change
    # this behavior.
    if [ ${#cachedfiles[@]} -eq 1 ] && [ ${#sourcefiles[@]} -eq 1 ] && [ "${cachedfiles[0]}" != "$scriptdir/.cache/$file_basename.*" ] && [ "${sourcefiles[0]}" != "$scriptdir/scripts/$file_basename.*" ]; then
        # Found one match of each, timestamps can be compared.
        cached_ts=$(date -r "${cachedfiles[0]}" '+%s')
        source_ts=$(date -r "${sourcefiles[0]}" '+%s')
        if [ "$cached_ts" = "$source_ts" ]; then
            # All checks passed, no update needed.
            echo "${cachedfiles[0]}"
            return 0
        fi
    fi
    # One of the above tests failed, so the cache needs to be updated.
    if [ ${#sourcefiles[@]} -gt 1 ]; then
        fail "There are multiple files in the $scriptdir/scripts matching the pattern $file_basename.*. There should be only one match for that pattern. Please rename some of them."
    fi
    # Delete any copies of this file currently in the cache.
    find -P "$scriptdir/.cache" -maxdepth 1 -name "$file_basename.*" -delete
    if [ ${#sourcefiles[@]} -lt 1 ] || [ "${sourcefiles[0]}" = "$scriptdir/scripts/$file_basename.*" ]; then
        # The original source file has disappeared. In this case, there's nothing
        # more for the _cache_update() function to do. If this is an error
        # condition, it will be handled elsewhere.
        echo ""
        return 0
    fi
    sourcefile="${sourcefiles[0]}"
    # What happens next depends on the file extension for the source file.
    sourcetype=$(path_extension "$sourcefile")
    cachedfile=""
    warning="# Do not modify this file! This file is automatically generated from the source\\n# file at $sourcefile.\\n# Modify that file instead.\\n"
    case "$sourcetype" in
        .sh)
            shellcheck=$(command -v shellcheck)
            if [ -n "$shellcheck" ]; then
                # Run shellcheck on the source file before using it, if available.
                if ! $shellcheck "$sourcefile" >/dev/null 2>&1; then
                    fail "The shell file in $sourcefile has changed and the new version isn't passing shellcheck. Please run \"shellcheck $sourcefile\" and then try again."
                fi
            fi
            # Shellcheck succeeded or is not available.
            cachedfile="$scriptdir/.cache/$file_basename.sh"
            # Inject the golem public code into this shell script.
            # See https://unix.stackexchange.com/a/193498 for an explanation of
            # this line noise.
            sed -n "/^# begin-golem-injected-code$/,/^# end-golem-injected-code$/p" "$scriptpath" | xargs -0 printf "\\n$warning\\n%s\\n" | sed '/^\s*[^#]\+/{;r /dev/stdin
                N;:l;$!n;$!bl;};${;/^$/!{;s/\\n$//;};//d;}' "$sourcefile" <(printf \\n) >"$cachedfile"
            if [ -n "$shellcheck" ]; then
                # Run shellcheck one more time on the completed cached file.
                if ! $shellcheck "$cachedfile" >/dev/null 2>&1; then
                    fail "There was a conflict between \"$sourcefile\" and the golem code that gets added to command scripts. Please run \"shellcheck $cachedfile\" and then try again."
                fi
            fi
        ;;
        .mdsh)
            # If mdsh is present, then markdown files ending in ".mdsh" can be
            # executed as commands if they pass all the sanity checks.
            mdsh=$(command -v mdsh)
            if [ -z "$mdsh" ]; then
                fail "mdsh is not installed or available in the current \$PATH. See https://github.com/bashup/mdsh for more information."
            fi
            shellcheck=$(command -v shellcheck)
            if [ -z "$shellcheck" ]; then
                fail "shellcheck is required for converting markdown documents to shell scripts. See https://github.com/koalaman/shellcheck for more information."
            fi
            # We really want to avoid getting a half-broken shell script in
            # the cache directory, so a temporary file is used here.
            tempfile=$(mktemp /tmp/golem.XXXXXX)
            if ! $mdsh --compile "$sourcefile" >"$tempfile" 2>&1; then
                rm "$tempfile"
                fail "mdsh was unable to parse this file: \"$sourcefile\""
            fi
            # mdsh may parse the file as a raw block; make sure that didn't happen.
            if ! grep -q -v '^\s*\(mdsh_raw[a-zA-Z_:-]*+=.*\)\?$' "$tempfile"; then
                rm "$tempfile"
                fail "mdsh did not correctly parse this file: \"$sourcefile\". Make sure it has code blocks beginning with \"\`\`\`bash\"."
            fi
            # So far, so good. Make sure the file has a "#!" near the top.
            # This is required for shellcheck to work properly.
            firstline=$(grep -v -m 1 '^\s*\(#[^!].*\)\?$' "$tempfile")
            if [[ ! "$firstline" =~ "^#!" ]]; then
                # Add an execution tag here.
                sed -i '1s:^:#!/bin/bash\n\n:' "$tempfile"
            fi
            # Copy the file out of /tmp now; it should be possible for the user
            # to review the compiled file if any errors are encountered after
            # this point.
            cat "$tempfile" > "$sourcefile-failed"
            rm "$tempfile"
            tempfile="$sourcefile-failed"
            # Shellcheck it. This is -required- for scripts imported through mdsh.
            if ! $shellcheck "$tempfile" >/dev/null 2>&1; then
                fail "The file converted by mdsh did not pass shellcheck. You can review the compiled file at \"$tempfile\"."
            fi
            # Use the sed line noise to generate the file in the cache.
            cachedfile="$scriptdir/.cache/$file_basename.sh"
            sed -n "/^# begin-golem-injected-code$/,/^# end-golem-injected-code$/p" "$scriptpath" | xargs -0 printf "\\n$warning\\n%s\\n" | sed '/^\s*[^#]\+/{;r /dev/stdin
                N;:l;$!n;$!bl;};${;/^$/!{;s/\\n$//;};//d;}' "$tempfile" <(printf \\n) >"$cachedfile"
            if ! $shellcheck "$cachedfile" >/dev/null 2>&1; then
                mv "$cachedfile" "$tempfile"
                fail "\"$sourcefile\" was successfully converted to a shell script by mdsh but failed a shellcheck test when golem functions were added to it. You can review the compiled file at \"$tempfile\"."
                cachedfile=""
            fi
            # The markdown script passed all tests. Nice!
            rm "$tempfile"
            ;;
        *)
            # All other file types: just copy the file into the cache and hope
            # the user knows what they're doing.
            filename=$(path_filename "$sourcefile")
            cachedfile="$scriptdir/.cache/$filename"
            cp "$sourcefile" "$cachedfile"
        ;;
    esac
    if [ -n "$cachedfile" ]; then
        chmod 0775 "$cachedfile"
        touch -r "$sourcefile" "$cachedfile"
    fi
    echo "$cachedfile"
    return 0
}


##
# Translate a given command string into a matching script to be run.
#
_shell_resolve_cmd () {
    command_string="$*"
    for i in $(seq 1 5); do
        matchfile=$(_find_cmd_file "$command_string")
        if [ -z "$matchfile" ]; then
            # Nothing found in either the scripts/ directory or the cache. The
            # caller will handle this with an error message.
            echo ""
            return 1
        fi
        matchcmd=$(path_basename "$matchfile")
        cachefile=$(_cache_check "$matchcmd")
        if [ -z "$cachefile" ]; then
            # The cached file didn't survive inspection, so try finding another
            # matching command script.
            continue
        fi
        echo "$cachefile"
        [ -n "$cachefile" ]
        return $?
    done
    # This should never happen.
    fail "No matching script could be found for this command after 5 tries."
}


##
# The content between begin-golem-injected-code and end-golem-injected-code
# gets inserted into the top of cached shell scripts.
#
# If shellcheck is available, then the cached scripts get shellchecked before
# and after this code is inserted.
#

# begin-golem-injected-code

# Exit with an error if an undefined variable is referenced.
set -u

# If any command in a pipeline fails, that return code will be used as the
# return code for the whole pipeline.
set -o pipefail

# Store the script's PID; this is used in the fail() function to terminate
# the script from subshells, loops, and the like.
scriptpid=$$

# Halt with a non-zero exit status if a TERM signal is received by this PID.
# This is used by the fail() function along with $scriptpid.
trap "exit 1" TERM


##
# Return the filename component of a path; this is identical to calling
# "basename [path]"
#
path_filename () {
    local path=""
    path=$(realpath -s -m "$1")
    echo "${path##*/}"
}


##
# Return the parent directory of a path; this is identical to calling
# "dirname [path]", but it also cleans up extra slashes in the path.
#
path_directory () {
    local filename=""
    filename=$(path_filename "$1")
    realpath -s -m "${1%$filename}"
}


##
# Return the basename of the filename component of a path. For example, return
# "my_file" from "/path/to/my_file.txt".
#
path_basename () {
    local filename="" base="" ext=""
    filename=$(path_filename "$1")
    base="${filename%%.[^.]*}"
    ext="${filename:${#base} + 1}"
    if [ -z "$base" ] && [ -n "$ext" ]; then
        echo ".$ext"
    else
        echo "$base"
    fi
}


##
# Return the extension (suffix) of the filename component of a path. Example:
# return ".tar.gz" for "my_file.tar.gz", and "" for ".test".
#
path_extension () {
    local filename="" basename=""
    filename=$(path_filename "$1")
    basename=$(path_basename "$filename")
    echo "${filename##$basename}"
}


##
# Generate a pseudorandom string. Accepts an argument for the length of the
# string; if no string length is provided, then it defaults to generating a
# string between 12 and 25 characters long.
#
# Similar-looking characters are filtered out of the result string.
#
random_string () {
    local -i num_chars=0
    if [ $# -gt 0 ]; then
        num_chars=$1
    else
        num_chars=$((12 + RANDOM % 12))
    fi
    tr -dc _A-Z-a-z-0-9 < /dev/urandom | tr -d '/+oO0lLiI1\n\r' | head -c $num_chars
}


##
# Write a message to stderr and continue execution.
#
warn () {
    echo "Warning: $*" >&2
}


##
# Write a message to stderr and exit immediately with a non-zero code.
#
fail () {
    echo "ERROR: $*" >&2
    kill -s TERM $scriptpid
}


##
# Ask the user a question and process the response, with options for defaults
# and timeouts.
#
ask () {
    # Options:
    #     --timeout N:     time out if there's no input for N seconds.
    #     --default ANS:   use ANS as the default answer on timeout or
    #                      if an empty answer is provided.
    #     --required:      don't accept a blank answer. Use this parameter
    #                      to make ask() accept any string.
    #
    # ask() gives the answer in its exit status, e.g.,
    # if ask "Continue?"; then ...
    local ans="" default="" prompt=""
    local -i timeout=0 required=0

    while [[ "$1" ]]
    do
        case "$1" in
            -d|--default)
                shift
                default=$1
                if [[ ! "$default" ]]; then warn "Missing default value"; fi
                default=$(tr '[:upper:]' '[:lower:]' <<< "$default")
                if [[ "$default" = "yes" ]]; then
                    default="y"
                elif [[ "$default" = "no" ]]; then
                    default="n"
                elif [ "$default" != "y" ] && [ "$default" != "n" ]; then
                    warn "Illegal default answer: $default"
                fi
                shift
            ;;

            -t|--timeout)
                shift
                if [[ ! "$1" ]]; then
                    warn "Missing timeout value"
                elif [[ ! "$1" =~ ^[0-9][0-9]*$ ]]; then
                    warn "Illegal timeout value: $1"
                else
                    timeout=$1
                fi
                shift
            ;;

            -r|--required)
                shift
                required=1
            ;;

            -*)
                warn "Unrecognized option: $1"
            ;;

            *)
                break
            ;;
        esac
    done

    # Sanity checks
    if [[ $timeout -ne 0  &&  ! "$default" ]]; then
        warn "ask(): Non-zero timeout requires a default answer"
        exit 1
    fi
    if [ $required -ne 0 ]; then
        if [ -n "$default" ] || [ "$timeout" -gt 0 ]; then
            warn "ask(): 'required' is not compatible with 'default' or 'timeout' parameters."
            exit 1
        fi
    fi
    if [[ ! "$*" ]]; then
        warn "Missing question"
        exit 1
    fi

    prompt="$*"
    if [ "$default" = "y" ]; then
        prompt="$prompt [Y/n] "
    elif [ "$default" = "n" ]; then
        prompt="$prompt [y/N] "
    elif [ $required -eq 1 ]; then
        prompt="$prompt (required) "
    else
        prompt="$prompt [y/n] "
    fi


    while [ -z "$ans" ]
    do
        if [[ $timeout -ne 0 ]]; then
            if ! read -r -t "$timeout" -p "$prompt" ans </dev/tty; then
                ans=$default
                echo
            else
                # Turn off timeout if answer entered.
                timeout=0
                if [[ ! "$ans" ]]; then ans=$default; fi
            fi
        else
            read -r -p "$prompt" ans </dev/tty
            if [[ ! "$ans" ]]; then
                if [ $required -eq 1 ]; then
                    warn "An answer is required."
                    ans=""
                else
                    ans=$default
                fi
            elif [ $required -eq 0 ]; then
                ans=$(tr '[:upper:]' '[:lower:]' <<< $ans)
                if [ "$ans" = "yes" ]; then
                    ans="y"
                elif [ "$ans" = "no" ]; then
                    ans="n"
                fi
            fi 
        fi

        if [ $required -eq 0 ]; then
            if [ "$ans" != 'y' ] && [ "$ans" != 'n' ]; then
                warn "Invalid answer. Please use y or n."
                ans=""
            fi
        fi
    done

    if [ $required -eq 1 ]; then
        echo $ans
        return 0
    fi

    [[ "$ans" = "y" || "$ans" == "yes" ]]
}

# end-golem-injected-code

################################################################################
#                                                                              #
#    Main program                                                              #
#                                                                              #
################################################################################

if [ $# -lt 1 ]; then
    # TODO: Needs a help subsystem.
    fail "No command provided"
fi

# Start a new blank line before any output if not in batch mode.
if [ "$1" == "-b" ] || [ "$1" == "-q" ]; then
    batch=1
    shift
else
    echo
fi

# Process arguments
# TODO: Full automatic argument processing before loading a script.
command_script=$(_shell_resolve_cmd "$*")
if [ -z "$command_script" ]; then
    fail "No matching command script found for \"$*\""
fi

if grep -q '^[[:space:]]*sudo ' "$command_script" && ! groups | grep -qw 'sudo'; then
    fail "It looks like this command requires superuser access and you're not in the 'sudo' group"
fi

/bin/bash "$command_script" "$*"

if [ $batch -eq 0 ]; then
    echo
fi
