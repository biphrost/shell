#!/bin/bash
# This script should be located at /usr/local/sbin/golem

################################################################################
#                                                                              #
#    Globals                                                                   #
#                                                                              #
################################################################################

# Name of this script.
# shellcheck disable=SC2034
scriptname=$(basename "$_")
# And the path.
scriptpath=$(readlink -m "$0")
scriptdir=$(dirname "$scriptpath")

# barf and exit if an undefined variable is referenced.
set -u

# if any command in a pipeline fails, that return code will be used as the
# return code of the whole pipeline.
set -o pipefail

# restrict newly created files to read/write by this user only.
umask 077

# Batch (quiet) mode?
batch=0



################################################################################
#                                                                              #
#    Functions                                                                 #
#                                                                              #
################################################################################

##
# _shell_resolve_cmd(): search for any golem scripts whose name matches the
# command entered by the user, starting with the most complex filenames first.
# 
_shell_resolve_cmd () {
    # The correct way to do this is to redirect the output from this
    # nasty series of commands as a redirect into `done`, e.g.:
    #     done < <(....)
    # But older verions of Bash vomit when you try that. Piping doesn't
    # work nicely on newer versions of Bash because it creates a subshell
    # which prevents later code from accessing any variables that are set,
    # exit doesn't work because the pipe is a subshell (it just exits the
    # pipe). So ... early return from a function!
    for cmdfile in "$scriptdir"/scripts/*; do echo ${#cmdfile} "$cmdfile"; done | sort -rn | cut -d " " -f 2 | while read -r filename; do
        # Convert the filename into a regular expression...
        regex=$(basename "$filename" | sed 's/\(\.sh\|\.py\)\?$//' | sed 's/_/[[:space:]]\\{1,\\}.*[[:space:]]*/g')
        # ...and then try to match it against the entered command.
        if echo "$*" | grep -q "^$regex"; then
            echo "$filename"
            return 0
        fi
    done
    echo ""
    return 1
}


random_string () {
    if [ $# -gt 0 ]; then
        local num_chars=$1
    else
        local num_chars=$((12 + RANDOM % 12))
    fi
    tr -dc _A-Z-a-z-0-9 < /dev/urandom | tr -d '/+oO0lLiI1\n\r' | head -c $num_chars
}


##
# _warn(): write a message to stderr.
# 
warn () {
    echo "$*" >&2
}


##
# ask(): ask the user a question and process the response, handling defaults,
# timeouts, and other options automatically.
# 
ask () {
    # Options:
    #     --timeout N:     time out if there's no input for N seconds.
    #     --default ANS:   use ANS as the default answer on timeout or
    #                      if an empty answer is provided.
    #     --required:      don't accept a blank answer. Use this parameter
    #                      to make ask() accept any string.
    #
    # ask() gives the answer in its exit status, e.g.,
    # if ask "Continue?"; then ...
    local ans=""
    local timeout=0
    local required=0
    local default=""
    local prompt=""

    while [[ "$1" ]]
    do
        case "$1" in
            -d|--default)
                shift
                default=$1
                if [[ ! "$default" ]]; then warn "Missing default value"; fi
                default=$(tr '[:upper:]' '[:lower:]' <<< "$default")
                if [[ "$default" = "yes" ]]; then
                    default="y"
                elif [[ "$default" = "no" ]]; then
                    default="n"
                elif [ "$default" != "y" ] && [ "$default" != "n" ]; then
                    warn "Illegal default answer: $default"
                fi
                shift
            ;;

            -t|--timeout)
                shift
                if [[ ! "$1" ]]; then
                    warn "Missing timeout value"
                elif [[ ! "$1" =~ ^[0-9][0-9]*$ ]]; then
                    warn "Illegal timeout value: $1"
                else
                    timeout=$1
                fi
                shift
            ;;

            -r|--required)
                shift
                required=1
            ;;

            -*)
                warn "Unrecognized option: $1"
            ;;

            *)
                break
            ;;
        esac
    done

    # Sanity checks
    if [[ $timeout -ne 0  &&  ! "$default" ]]; then
        warn "ask(): Non-zero timeout requires a default answer"
        exit 1
    fi
    if [ $required -ne 0 ]; then
        if [ -n "$default" ] || [ "$timeout" -gt 0 ]; then
            warn "ask(): 'required' is not compatible with 'default' or 'timeout' parameters."
            exit 1
        fi
    fi
    if [[ ! "$*" ]]; then
        warn "Missing question"
        exit 1
    fi

    prompt="$*"
    if [ "$default" = "y" ]; then
        prompt="$prompt [Y/n] "
    elif [ "$default" = "n" ]; then
        prompt="$prompt [y/N] "
    elif [ $required -eq 1 ]; then
        prompt="$prompt (required) "
    else
        prompt="$prompt [y/n] "
    fi


    while [ -z "$ans" ]
    do
        if [[ $timeout -ne 0 ]]; then
            if ! read -r -t "$timeout" -p "$prompt" ans </dev/tty; then
                ans=$default
                echo
            else
                # Turn off timeout if answer entered.
                timeout=0
                if [[ ! "$ans" ]]; then ans=$default; fi
            fi
        else
            read -r -p "$prompt" ans </dev/tty
            if [[ ! "$ans" ]]; then
                if [ $required -eq 1 ]; then
                    warn "An answer is required."
                    ans=""
                else
                    ans=$default
                fi
            elif [ $required -eq 0 ]; then
                ans=$(tr '[:upper:]' '[:lower:]' <<< $ans)
                if [ "$ans" = "yes" ]; then
                    ans="y"
                elif [ "$ans" = "no" ]; then
                    ans="n"
                fi
            fi 
        fi

        if [ $required -eq 0 ]; then
            if [ "$ans" != 'y' ] && [ "$ans" != 'n' ]; then
                warn "Invalid answer. Please use y or n."
                ans=""
            fi
        fi
    done

    if [ $required -eq 1 ]; then
        echo $ans
        return 0
    fi

    [[ "$ans" = "y" || "$ans" == "yes" ]]
}


################################################################################
#                                                                              #
#    Main program                                                              #
#                                                                              #
################################################################################

if [ $# -lt 1 ]; then
    # TODO: Needs a help subsystem.
    echo "No command provided"
    exit 1
fi

# Start a new blank line before any output if not in batch mode.
if [ "$1" == "-b" ] || [ "$1" == "-q" ]; then
    batch=1
    shift
else
    echo
fi

# Process arguments
# TODO: Full automatic argument processing before loading a script.
golem_script=$(_shell_resolve_cmd "$*")
if [ -z "$golem_script" ]; then
    echo "Error: I don't understand \"$*\""
    exit 1
fi

if grep -q '^[[:space:]]*sudo ' "$golem_script"; then
    if ! groups | grep -qw 'sudo'; then
        echo "It looks like this command requires superuser access and you're not in the 'sudo' group"
        exit 1
    fi
fi

# shellcheck disable=SC1090
. "$golem_script"

if [ $batch -eq 0 ]; then
    echo
fi
